<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Gpsd-dev] Smaller patch to try on 2.21
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/gpsd-dev/2005-May/index.html" >
   <LINK REL="made" HREF="mailto:gpsd-dev%40lists.berlios.de?Subject=Re%3A%20%5BGpsd-dev%5D%20Smaller%20patch%20to%20try%20on%202.21&In-Reply-To=%3C200505171853.j4HIrt6M011100%40snark.thyrsus.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001712.html">
   <LINK REL="Next"  HREF="001723.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Gpsd-dev] Smaller patch to try on 2.21</H1>
    <B>Eric S. Raymond</B> 
    <A HREF="mailto:gpsd-dev%40lists.berlios.de?Subject=Re%3A%20%5BGpsd-dev%5D%20Smaller%20patch%20to%20try%20on%202.21&In-Reply-To=%3C200505171853.j4HIrt6M011100%40snark.thyrsus.com%3E"
       TITLE="[Gpsd-dev] Smaller patch to try on 2.21">esr at snark.thyrsus.com
       </A><BR>
    <I>Tue May 17 20:53:55 CEST 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="001712.html">[Gpsd-dev] Announcing release 2.24 of gpsd
</A></li>
        <LI>Next message: <A HREF="001723.html">[Gpsd-dev] link to the ebuild on the website
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1715">[ date ]</a>
              <a href="thread.html#1715">[ thread ]</a>
              <a href="subject.html#1715">[ subject ]</a>
              <a href="author.html#1715">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>I inadvertently diffed between 2.21 and 2,23.  Here is a much smaller
patch to try on 2.21. I hope this makes your bug show up...

diff -r -u gpsd-2.21/gpsd.c gpsd-2.22/gpsd.c
--- gpsd-2.21/gpsd.c	2005-04-12 19:33:06.000000000 -0400
+++ gpsd-2.22/gpsd.c	2005-04-25 10:37:38.000000000 -0400
@@ -36,7 +36,17 @@
 
 #define QLEN			5
 
-#define LEAP_SECONDS	13	/* good for 2005 */
+/*
+ * The current (fixed) leap-second correction, and the future Unix
+ * time after which to start hunting leap-second corrections from GPS
+ * subframe data if the GPS doesn't supply them any more readily.
+ * Currently 1 Jan 2006, as the current fixed correction will be good
+ * until at least then.  Deferring the check is a hack to speed up fix
+ * acquisition -- subframe data is bulky enough to substantially
+ * increase latency.
+ */
+#define LEAP_SECONDS	13
+#define START_SUBFRAME	1136091600
 
 static fd_set all_fds;
 static int debuglevel, in_background = 0;
@@ -537,12 +547,12 @@
 		else
 		    strcat(phrase, &quot;      ?&quot;);
 		strcat(phrase, &quot; ?&quot;);	/* can't yet derive track error */ 
-		if (whoami-&gt;device-&gt;gpsdata.valid &amp; SPEEDERR_SET)
+		if (whoami-&gt;device-&gt;gpsdata.set &amp; SPEEDERR_SET)
 		    sprintf(phrase+strlen(phrase), &quot; %5.2f&quot;,
 			    whoami-&gt;device-&gt;gpsdata.fix.eps);		    
 		else
 		    strcat(phrase, &quot;      ?&quot;);
-		if (whoami-&gt;device-&gt;gpsdata.valid &amp; CLIMBERR_SET)
+		if (whoami-&gt;device-&gt;gpsdata.set &amp; CLIMBERR_SET)
 		    sprintf(phrase+strlen(phrase), &quot; %5.2f&quot;,
 			    whoami-&gt;device-&gt;gpsdata.fix.epc);		    
 		else
@@ -551,7 +561,7 @@
 	    break;
 	case 'P':
 	    if (assign_channel(whoami) &amp;&amp; have_fix(whoami-&gt;device))
-		sprintf(phrase, &quot;,P=%.4f %.4f&quot;, 
+		sprintf(phrase, &quot;,P=%.6f %.6f&quot;, 
 			whoami-&gt;device-&gt;gpsdata.fix.latitude, 
 			whoami-&gt;device-&gt;gpsdata.fix.longitude);
 	    else
@@ -647,7 +657,7 @@
 		    strcat(phrase, whoami-&gt;device-&gt;gpsdata.tag);
 		else
 		    strcat(phrase, &quot;-&quot;);
-		if (whoami-&gt;device-&gt;gpsdata.valid &amp; TIME_SET)
+		if (whoami-&gt;device-&gt;gpsdata.set &amp; TIME_SET)
 		    sprintf(phrase+strlen(phrase), &quot; %f &quot;, 
 			    whoami-&gt;device-&gt;gpsdata.sentence_time);
 		else
@@ -747,7 +757,9 @@
 		if (subscribers[cfd].device == *chp)
 		    subscribers[cfd].device = NULL;
 	    *chp = NULL;
-	}
+	    write(sfd, &quot;OK\n&quot;, 3);
+	} else
+	    write(sfd, &quot;ERROR\n&quot;, 6);
 	free(stash);
     } else if (buf[0] == '+') {
 	p = getline(buf+1, &amp;stash);
@@ -755,7 +767,10 @@
 	    gpsd_report(1,&quot;&lt;= control(%d): %s already active \n&quot;, sfd, stash);
 	else {
 	    gpsd_report(1,&quot;&lt;= control(%d): adding %s \n&quot;, sfd, stash);
-	    open_device(stash, 1);
+	    if (open_device(stash, 1))
+		write(sfd, &quot;OK\n&quot;, 3);
+	    else
+		write(sfd, &quot;ERROR\n&quot;, 6);
 	}
 	free(stash);
     }
@@ -878,6 +893,10 @@
     FD_SET(msock, &amp;all_fds);
     FD_ZERO(&amp;control_fds);
 
+    /* optimization hack to defer having to read subframe data */
+    if (time(NULL) &lt; START_SUBFRAME)
+	context.valid |= LEAP_SECOND_VALID;
+
     device = open_device(device_name, nowait);
     if (!device) {
 	gpsd_report(0, &quot;exiting - GPS device nonexistent or can't be read\n&quot;);
diff -r -u gpsd-2.21/gpsd.h gpsd-2.22/gpsd.h
--- gpsd-2.21/gpsd.h	2005-04-12 12:26:15.000000000 -0400
+++ gpsd-2.22/gpsd.h	2005-04-21 12:25:58.000000000 -0400
@@ -8,7 +8,7 @@
 #ifdef EARTHMATE_ENABLE
 #define ZODIAC_ENABLE	
 #endif
-#if defined(ZODIAC_ENABLE) || defined(SIRF_ENABLE) || defined(GARMIN_ENABLE)
+#if defined(ZODIAC_ENABLE) || defined(SIRFII_ENABLE) || defined(GARMIN_ENABLE)
 #define BINARY_ENABLE	
 #endif
 #if defined(TRIPMATE_ENABLE) || defined(BINARY_ENABLE)
@@ -18,49 +18,14 @@
 #define NMEA_MAX	82		/* max length of NMEA sentence */
 #define NMEA_BIG_BUF	(2*NMEA_MAX+1)	/* longer than longest NMEA sentence */
 
-/*
- * User Equivalent Range Error
- * UERE is the square root of the sum of the squares of individual
- * errors.  We compute based on the following error budget for
- * satellite range measurements.  Note: this is only used if the
- * GPS doesn't report estimated position error itself.
- *
- * From R.B Langley's 1997 &quot;The GPS error budget&quot;. 
- * GPS World , Vol. 8, No. 3, pp. 51-56
- *
- * Atmospheric error -- ionosphere                 7.0m
- * Atmospheric error -- troposphere                0.7m
- * Clock and ephemeris error                       3.6m
- * Receiver noise                                  1.5m
- * Multipath effect                                1.2m
- *
- * From Hoffmann-Wellenhof et al. (1997), &quot;GPS: Theory and Practice&quot;, 4th
- * Ed., Springer.
- *
- * Code range noise (C/A)                          0.3m
- * Code range noise (P-code)                       0.03m
- * Phase range                                     0.005m
- *
- * Taking the square root of the sum of aa squares...
- * UERE=sqrt(7.0^2 + 0.7^2 + 3.6^2 + 1.5^2 + 1.2^2 + 0.3^2 + 0.03^2 + 0.005^2)
- *
- * Note: we're assume these are 1-sigma error ranges. This needs to
- * be checked in the sources.
- *
- * See <A HREF="http://www.seismo.berkeley.edu/~battag/GAMITwrkshp/lecturenotes/unit1/">http://www.seismo.berkeley.edu/~battag/GAMITwrkshp/lecturenotes/unit1/</A>
- * for discussion.
- *
- * DGPS corrects for atmospheric distortion, ephemeris error, and satellite/
- * receiver clock error.  Thus:
- * UERE =  sqrt(1.5^2 + 1.2^2 + 0.3^2 + 0.03^2 + 0.005^2)
- */
-#define UERE_NO_DGPS	8.1382
-#define UERE_WITH_DGPS	1.9444
+/* only used if the GPS doesn't report estimated position error itself */
+#define UERE_NO_DGPS	8	/* meters */
+#define UERE_WITH_DGPS	2	/* meters */
 #define UERE(session)	((session-&gt;dsock==-1) ? UERE_NO_DGPS : UERE_WITH_DGPS)
 
 struct gps_context_t {
     int valid;
-#define LEAP_SECOND_VALID	0x01
+#define LEAP_SECOND_VALID	0x01	/* we have or don't need correctiomn */
     int leap_seconds;
 };
 
@@ -123,6 +88,10 @@
 #ifdef BINARY_ENABLE
     struct gps_fix_t lastfix;	/* use to compute uncertainties */
     unsigned int driverstate;	/* for private use */
+#define SIRF_LT_231	0x01		/* SiRF at firmware rev &lt; 231 */
+#define SIRF_EQ_231     0x02            /* SiRF at firmware rev == 231 */
+#define SIRF_GE_232     0x04            /* SiRF at firmware rev &gt;= 232 */
+#define UBLOX   	0x08		/* uBlox firmware with packet 0x62 */
     double separation;		/* Geoidal separation, MSL - WGS84 (Meters) */
 #define NO_SEPARATION	-99999	/* must be out of band */
     double mag_var;		/* Magnetic variation in degrees */  
@@ -191,6 +160,7 @@
 extern void ecef_to_wgs84fix(struct gps_fix_t *,
 			     double, double, double, 
 			     double, double, double);
+extern void dop(int, struct gps_data_t *);
 
 /* External interface */
 extern int gpsd_open_dgps(char *);
Only in gpsd-2.22: gpsd.spec
diff -r -u gpsd-2.21/gps.h gpsd-2.22/gps.h
--- gpsd-2.21/gps.h	2005-04-12 16:07:21.000000000 -0400
+++ gpsd-2.22/gps.h	2005-04-19 11:32:52.000000000 -0400
@@ -72,7 +72,7 @@
 };
 
 struct gps_data_t {
-    unsigned long valid;	/* validity mask */
+    unsigned long set;	/* has field been set since this was last cleared? */
 #define ONLINE_SET	0x00000001
 #define TIME_SET	0x00000002
 #define TIMERR_SET	0x00000004
diff -r -u gpsd-2.21/gpsutils.c gpsd-2.22/gpsutils.c
--- gpsd-2.21/gpsutils.c	2005-03-28 18:47:44.000000000 -0500
+++ gpsd-2.22/gpsutils.c	2005-04-20 21:51:53.000000000 -0400
@@ -157,3 +157,211 @@
 	a = -1;
     return CalcRad((lat1+lat2) / 2) * acos(a);
 }
+
+/*****************************************************************************
+
+Carl Carter of SiRF supplied this algorithm for computing DOPs from 
+a list of visible satellites...
+
+For satellite n, let az(n) = azimuth angle from North and el(n) be elevation.
+Let:
+
+    a(k, 1) = sin az(k) * cos el(k)
+    a(k, 2) = cos az(k) * cos el(k)
+    a(k, 3) = sin el(k)
+
+Then form the line-of-sight matrix A for satellites used in the solution:
+
+    | a(1,1) a(1,2) a(1,3) 1 |
+    | a(2,1) a(2,2) a(2,3) 1 |
+    |   :       :      :   : |
+    | a(n,1) a(n,2) a(n,3) 1 |
+
+And its transpose A~:
+
+    |a(1, 1) a(2, 1) .  .  .  a(n, 1) |
+    |a(1, 2) a(2, 2) .  .  .  a(n, 2) |
+    |a(1, 3) a(2, 3) .  .  .  a(n, 3) |
+    |    1       1   .  .  .     1    |
+
+Compute the covariance matrix (A~*A)^-1, which is guaranteed symmetric:
+
+    | s(x)^2    s(x)*s(y)  s(x)*s(z)  s(x)*s(t) | 
+    | s(x)*s(y) s(y)^2     s(y)*s(z)  s(y)*s(t) |
+    | s(z)*s(t) s(y)*s(z)  s(z)^2     s(z)*s(t) |
+    | s(x)*s(t) s(y)*s(t)  s(z)*s(t)  s(z)^2    |
+
+Then:
+
+GDOP = sqrt(s(x)^2 + s(y)^2 + s(z)^2 + s(t)^2)
+TDOP = sqrt(s(t)^2)
+PDOP = sqrt(s(x)^2 + s(y)^2 + s(z)^2)
+HDOP = sqrt(s(x)^2 + s(y)^2)
+VDOP = sqrt(s(y)^2)
+
+Here's how we implement it...
+
+First, each compute element P(i,j) of the 4x4 product A~*A.
+If S(k=1,k=n): f(...) is the sum of f(...) as k varies from 1 to n, then
+applying the definition of matrix product tells us: 
+
+P(i,j) = S(k=1,k=n): B(i, k) * A(k, j) + 1
+
+But because B is the transpose of A, this reduces to 
+
+P(i,j) = S(k=1,k=n): A(k, i) * A(k, j) + 1
+
+******************************************************************************/
+
+static int invert(double mat[4][4], double inverse[4][4])
+{
+  // Find all NECESSARY 2x2 subdeterminants
+  //double Det2_12_01 = mat[1][0]*mat[2][1] - mat[1][1]*mat[2][0];
+  //double Det2_12_02 = mat[1][0]*mat[2][2] - mat[1][2]*mat[2][0];
+  //double Det2_12_03 = mat[1][0]*mat[2][3] - mat[1][3]*mat[2][0];
+  //double Det2_12_12 = mat[1][1]*mat[2][2] - mat[1][2]*mat[2][1];
+  //double Det2_12_13 = mat[1][1]*mat[2][3] - mat[1][3]*mat[2][1];
+  //double Det2_12_23 = mat[1][2]*mat[2][3] - mat[1][3]*mat[2][2];
+  double Det2_13_01 = mat[1][0]*mat[3][1] - mat[1][1]*mat[3][0];
+  //double Det2_13_02 = mat[1][0]*mat[3][2] - mat[1][2]*mat[3][0];
+  double Det2_13_03 = mat[1][0]*mat[3][3] - mat[1][3]*mat[3][0];
+  //double Det2_13_12 = mat[1][1]*mat[3][2] - mat[1][2]*mat[3][1];  
+  double Det2_13_13 = mat[1][1]*mat[3][3] - mat[1][3]*mat[3][1];
+  //double Det2_13_23 = mat[1][2]*mat[3][3] - mat[1][3]*mat[3][2];  
+  double Det2_23_01 = mat[2][0]*mat[3][1] - mat[2][1]*mat[3][0];
+  double Det2_23_02 = mat[2][0]*mat[3][2] - mat[2][2]*mat[3][0];
+  double Det2_23_03 = mat[2][0]*mat[3][3] - mat[2][3]*mat[3][0];
+  double Det2_23_12 = mat[2][1]*mat[3][2] - mat[2][2]*mat[3][1];
+  double Det2_23_13 = mat[2][1]*mat[3][3] - mat[2][3]*mat[3][1];
+  double Det2_23_23 = mat[2][2]*mat[3][3] - mat[2][3]*mat[3][2];
+
+  // Find all NECESSARY 3x3 subdeterminants
+  //double Det3_012_012 = mat[0][0]*Det2_12_12 - mat[0][1]*Det2_12_02 
+  //				+ mat[0][2]*Det2_12_01;
+  //double Det3_012_013 = mat[0][0]*Det2_12_13 - mat[0][1]*Det2_12_03 
+  //				+ mat[0][3]*Det2_12_01;
+  //double Det3_012_023 = mat[0][0]*Det2_12_23 - mat[0][2]*Det2_12_03
+  //				+ mat[0][3]*Det2_12_02;
+  //double Det3_012_123 = mat[0][1]*Det2_12_23 - mat[0][2]*Det2_12_13 
+  //				+ mat[0][3]*Det2_12_12;
+  //double Det3_013_012 = mat[0][0]*Det2_13_12 - mat[0][1]*Det2_13_02 
+  //				+ mat[0][2]*Det2_13_01;
+  double Det3_013_013 = mat[0][0]*Det2_13_13 - mat[0][1]*Det2_13_03
+				+ mat[0][3]*Det2_13_01;
+  //double Det3_013_023 = mat[0][0]*Det2_13_23 - mat[0][2]*Det2_13_03
+  //				+ mat[0][3]*Det2_13_02;
+  //double Det3_013_123 = mat[0][1]*Det2_13_23 - mat[0][2]*Det2_13_13
+  //				+ mat[0][3]*Det2_13_12;
+  //double Det3_023_012 = mat[0][0]*Det2_23_12 - mat[0][1]*Det2_23_02 
+  //				+ mat[0][2]*Det2_23_01;
+  //double Det3_023_013 = mat[0][0]*Det2_23_13 - mat[0][1]*Det2_23_03
+  //				+ mat[0][3]*Det2_23_01;
+  double Det3_023_023 = mat[0][0]*Det2_23_23 - mat[0][2]*Det2_23_03
+				+ mat[0][3]*Det2_23_02;
+  //double Det3_023_123 = mat[0][1]*Det2_23_23 - mat[0][2]*Det2_23_13
+  //				+ mat[0][3]*Det2_23_12;
+  double Det3_123_012 = mat[1][0]*Det2_23_12 - mat[1][1]*Det2_23_02 
+				+ mat[1][2]*Det2_23_01;
+  double Det3_123_013 = mat[1][0]*Det2_23_13 - mat[1][1]*Det2_23_03 
+				+ mat[1][3]*Det2_23_01;
+  double Det3_123_023 = mat[1][0]*Det2_23_23 - mat[1][2]*Det2_23_03 
+				+ mat[1][3]*Det2_23_02;
+  double Det3_123_123 = mat[1][1]*Det2_23_23 - mat[1][2]*Det2_23_13 
+				+ mat[1][3]*Det2_23_12;
+
+  // Find the 4x4 determinant
+  static double det;
+          det =   mat[0][0]*Det3_123_123 
+		- mat[0][1]*Det3_123_023 
+		+ mat[0][2]*Det3_123_013 
+		- mat[0][3]*Det3_123_012;
+
+  // ??? Should the test be made: fabs(det) &lt;= epsilon ???
+  if (det == 0.0)
+      return 0;
+
+  inverse[0][0] =  Det3_123_123 / det;
+  //inverse[0][1] = -Det3_023_123 / det;
+  //inverse[0][2] =  Det3_013_123 / det;
+  //inverse[0][3] = -Det3_012_123 / det;
+
+  //inverse[1][0] = -Det3_123_023 / det;
+  inverse[1][1] =  Det3_023_023 / det;
+  //inverse[1][2] = -Det3_013_023 / det;
+  //inverse[1][3] =  Det3_012_023 / det;
+
+  //inverse[2][0] =  Det3_123_013 / det;
+  //inverse[2][1] = -Det3_023_013 / det;
+  inverse[2][2] =  Det3_013_013 / det;
+  //inverse[2][3] = -Det3_012_013 / det;
+
+  //inverse[3][0] = -Det3_123_012 / det;
+  //inverse[3][1] =  Det3_023_012 / det;
+  //inverse[3][2] = -Det3_013_012 / det;
+  //inverse[3][3] =  Det3_012_012 / det;
+
+  return 1;
+}  
+
+void dop(int channels, struct gps_data_t *gpsdata)
+{
+    double prod[4][4];
+    double inv[4][4];
+    double satpos[MAXCHANNELS][4];
+    int i, j, k, n;
+
+    gpsd_report(0, &quot;Satellite picture:\n&quot;);
+    for (k = 0; k &lt; MAXCHANNELS; k++) {
+	if (gpsdata-&gt;used[k])
+	    gpsd_report(0, &quot;az: %d el: %d  SV: %d\n&quot;,
+			gpsdata-&gt;azimuth[k], gpsdata-&gt;elevation[k], gpsdata-&gt;used[k]);
+    }
+
+    for (n = k = 0; k &lt; channels; k++) {
+	if (!gpsdata-&gt;used[k])
+	    continue;
+	satpos[n][0] = sin(gpsdata-&gt;azimuth[k]*DEG_2_RAD)
+	    * cos(gpsdata-&gt;elevation[k]*DEG_2_RAD);
+	satpos[n][1] = cos(gpsdata-&gt;azimuth[k]*DEG_2_RAD)
+	    * cos(gpsdata-&gt;elevation[k]*DEG_2_RAD);
+	satpos[n][2] = sin(gpsdata-&gt;elevation[k]*DEG_2_RAD);
+	satpos[n][3] = 1;
+	n++;
+    }
+
+    gpsd_report(0, &quot;Line-of-sight matrix:\n&quot;);
+    for (k = 0; k &lt; n; k++) {
+	gpsd_report(0, &quot;%f %f %f %f\n&quot;,
+		    satpos[k][0], satpos[k][1], satpos[k][2], satpos[k][3]);
+    }
+
+    for (i = 0; i &lt; 4; i++)
+	for (j = 0; j &lt; 4; j++) {
+	    prod[i][j] = 1;
+	    for (k = 0; k &lt; n; k++)
+		prod[i][j] += satpos[k][i] + satpos[k][j];
+	}
+
+    gpsd_report(0, &quot;product:\n&quot;);
+    for (k = 0; k &lt; 4; k++) {
+	gpsd_report(0, &quot;%f %f %f %f\n&quot;,
+		    prod[k][0], prod[k][1], prod[k][2], prod[k][3]);
+    }
+
+    if (invert(prod, inv)) {
+	gpsd_report(0, &quot;inverse:\n&quot;);
+	for (k = 0; k &lt; 4; k++) {
+	    gpsd_report(0, &quot;%f %f %f %f\n&quot;,
+			inv[k][0], inv[k][1], inv[k][2], inv[k][3]);
+	}
+	gpsd_report(0, &quot;HDOP: reported = %f, computed = %f\n&quot;,
+		    gpsdata-&gt;hdop, sqrt(inv[0][0] + inv[1][1]));
+    } else
+	gpsd_report(0, &quot;Matrix is singular.\n&quot;);
+
+    //gpsdata-&gt;hdop = sqrt(diag[0] + diag[1]);
+    //gpsdata-&gt;vdop = sqrt(diag[1]);
+    //gpsdata-&gt;pdop = sqrt(diag[0] + diag[1] + diag[2]);
+}
+#ifdef __UNUSED__
+#endif /* __UNUSED */
diff -r -u gpsd-2.21/gpsutils.h gpsd-2.22/gpsutils.h
--- gpsd-2.21/gpsutils.h	2005-04-01 17:08:15.000000000 -0500
+++ gpsd-2.22/gpsutils.h	2005-04-20 14:41:08.000000000 -0400
@@ -9,3 +9,8 @@
 
 /* return geoid separtion (MSL - WGS84) in meters, given a lat/lot in degrees */
 extern double wgs84_separation(double lat, double lon);
+
+/* guess at preferred units from environment and compiled in defaults
+ * return: 0 = miles/feet, 1 = knots/feet, 2 = km/meters
+ */
+extern int gpsd_units(void);
diff -r -u gpsd-2.21/libgps.c gpsd-2.22/libgps.c
--- gpsd-2.21/libgps.c	2005-04-12 16:06:13.000000000 -0400
+++ gpsd-2.22/libgps.c	2005-04-20 23:08:46.000000000 -0400
@@ -8,6 +8,65 @@
 
 #include &quot;gpsd.h&quot;
 
+/* 
+ * check the environment to determine proper GPS units
+ *
+ * clients should only call this if no user preference on the command line or
+ * Xresources
+ *
+ * return 0 - Use miles/feet
+ *        1 - Use knots/feet
+ *        2 - Use km/meters
+ * 
+ * In order check these environment vars:
+ *    GPSD_UNITS one of: 
+ *            	imperial   = miles/feet
+ *              nautical   = knots/feet
+ *              metric     = km/meters
+ *    LC_MEASUREMENT
+ *		en_US      = miles/feet
+ *              C          = miles/feet
+ *              POSIX      = miles/feet
+ *              [other]    = km/meters
+ *    LANG
+ *		en_US      = miles/feet
+ *              C          = miles/feet
+ *              POSIX      = miles/feet
+ *              [other]    = km/meters
+ *
+ * if none found then return compiled in default
+ */
+int gpsd_units(void)
+{
+	char *envu = NULL;
+
+ 	if ((envu = getenv(&quot;GPSD_UNITS&quot;)) &amp;&amp; *envu) {
+		if (strcasecmp(envu, &quot;imperial&quot;)) {
+			return 0;
+		}
+		if (strcasecmp(envu, &quot;nautical&quot;)) {
+			return 1;
+		}
+		if (strcasecmp(envu, &quot;metric&quot;)) {
+			return 2;
+		}
+		/* unrecognized, ignore it */
+	}
+ 	if (((envu = getenv(&quot;LC_MEASUREMENT&quot;)) &amp;&amp; *envu) 
+ 	    || ((envu = getenv(&quot;LANG&quot;)) &amp;&amp; *envu)) {
+		if (   strstr(envu, &quot;_US&quot;) 
+		    || strcasecmp(envu, &quot;C&quot;)
+		    || strcasecmp(envu, &quot;POSIX&quot;)) {
+			return 0;
+		}
+		/* Other, must be metric */
+		return 2;
+	}
+	/* TODO: allow a compile time default here */
+	return 0;
+}
+
+
 void gps_clear_fix(struct gps_fix_t *fixp)
 /* stuff a fix structure with recognizable out-of-band values */
 {
@@ -82,7 +141,6 @@
     char *ns, *sp, *tp;
     int i;
 
-    gpsdata-&gt;valid = 0;
     for (ns = buf; ns; ns = strstr(ns+1, &quot;GPSD&quot;)) {
 	if (!strncmp(ns, &quot;GPSD&quot;, 4)) {
 	    for (sp = ns + 5; ; sp = tp) {
@@ -96,7 +154,7 @@
 			    gpsdata-&gt;fix.altitude = ALTITUDE_NOT_VALID;
 		    } else {
 		        sscanf(sp, &quot;A=%lf&quot;, &amp;gpsdata-&gt;fix.altitude);
-		        gpsdata-&gt;valid |= ALTITUDE_SET;
+		        gpsdata-&gt;set |= ALTITUDE_SET;
 		    }
 		    break;
 		case 'B':
@@ -117,7 +175,7 @@
 			gpsdata-&gt;fix.time = TIME_NOT_VALID;
 		    else {
 			gpsdata-&gt;fix.time = iso8601_to_unix(sp+2);
-			gpsdata-&gt;valid |= TIME_SET;
+			gpsdata-&gt;set |= TIME_SET;
 		    }
 		    break;
 		case 'E':
@@ -128,7 +186,7 @@
 		    } else {
 		        sscanf(sp, &quot;E=%lf %lf %lf&quot;, 
 			   &amp;gpsdata-&gt;epe,&amp;gpsdata-&gt;fix.eph,&amp;gpsdata-&gt;fix.epv);
-		        gpsdata-&gt;valid |= HERR_SET| VERR_SET | PERR_SET;
+		        gpsdata-&gt;set |= HERR_SET| VERR_SET | PERR_SET;
 		    }
 		    break;
 		case 'F':
@@ -138,7 +196,7 @@
 			if (gpsdata-&gt;gps_device)
 			    free(gpsdata-&gt;gps_id);
 			gpsdata-&gt;gps_device = strdup(sp+2);
-			gpsdata-&gt;valid |= DEVICE_SET;
+			gpsdata-&gt;set |= DEVICE_SET;
 		    }
 		    break;
 		case 'I':
@@ -148,7 +206,7 @@
 			if (gpsdata-&gt;gps_id)
 			    free(gpsdata-&gt;gps_id);
 			gpsdata-&gt;gps_id = strdup(sp+2);
-			gpsdata-&gt;valid |= DEVICEID_SET;
+			gpsdata-&gt;set |= DEVICEID_SET;
 		    }
 		    break;
 		case 'K':
@@ -158,7 +216,7 @@
 			free(gpsdata-&gt;devicelist);
 			gpsdata-&gt;devicelist = NULL;
 			gpsdata-&gt;ndevices = -1;
-			gpsdata-&gt;valid |= DEVICELIST_SET;
+			gpsdata-&gt;set |= DEVICELIST_SET;
 		    }    
 		    if (sp[2] != '?') {
 			gpsdata-&gt;ndevices = strtol(sp+2, &amp;sp, 10);
@@ -168,7 +226,7 @@
 			gpsdata-&gt;devicelist[i=0] = strtok_r(sp+2, &quot; \r\n&quot;, &amp;ns);
 			while ((sp = strtok_r(NULL, &quot; \r\n&quot;,  &amp;ns)))
 			    gpsdata-&gt;devicelist[++i] = strdup(sp);
-			gpsdata-&gt;valid |= DEVICELIST_SET;
+			gpsdata-&gt;set |= DEVICELIST_SET;
 		    }
 		    break;
 		case 'M':
@@ -176,7 +234,7 @@
 		        gpsdata-&gt;fix.mode = MODE_NOT_SEEN;
 		    } else {
 		        gpsdata-&gt;fix.mode = atoi(sp+2);
-		        gpsdata-&gt;valid |= MODE_SET;
+		        gpsdata-&gt;set |= MODE_SET;
 		    }
 		    break;
 		case 'N':
@@ -187,7 +245,7 @@
 		    break;
 		case 'O':
 		    if (sp[2] == '?') {
-			gpsdata-&gt;valid = MODE_SET | STATUS_SET;
+			gpsdata-&gt;set = MODE_SET | STATUS_SET;
 			gps_clear_fix(&amp;gpsdata-&gt;fix);
 		    } else {
 			struct gps_fix_t nf;
@@ -214,21 +272,21 @@
 #undef DEFAULT
 			    nf.mode = (alt[0] == '?') ? MODE_2D : MODE_3D;
 			    if (nf.mode == MODE_3D)
-				gpsdata-&gt;valid |= ALTITUDE_SET | CLIMB_SET;
+				gpsdata-&gt;set |= ALTITUDE_SET | CLIMB_SET;
 			    if (nf.eph != UNCERTAINTY_NOT_VALID)
-				gpsdata-&gt;valid |= HERR_SET;
+				gpsdata-&gt;set |= HERR_SET;
 			    if (nf.epv != UNCERTAINTY_NOT_VALID)
-				gpsdata-&gt;valid |= VERR_SET;
+				gpsdata-&gt;set |= VERR_SET;
 			    if (nf.track != TRACK_NOT_VALID)
-				gpsdata-&gt;valid |= TRACK_SET | SPEED_SET;
+				gpsdata-&gt;set |= TRACK_SET | SPEED_SET;
 			    if (nf.eps != UNCERTAINTY_NOT_VALID)
-				gpsdata-&gt;valid |= SPEEDERR_SET;
+				gpsdata-&gt;set |= SPEEDERR_SET;
 			    if (nf.epc != UNCERTAINTY_NOT_VALID)
-				gpsdata-&gt;valid |= CLIMBERR_SET;
+				gpsdata-&gt;set |= CLIMBERR_SET;
 
 			    gpsdata-&gt;fix = nf;
 			    strcpy(gpsdata-&gt;tag, tag);
-			    gpsdata-&gt;valid = TIME_SET|TIMERR_SET|LATLON_SET|MODE_SET;
+			    gpsdata-&gt;set = TIME_SET|TIMERR_SET|LATLON_SET|MODE_SET;
 			}
 		    }
 		    break;
@@ -239,7 +297,7 @@
 		    } else {
 		        sscanf(sp, &quot;P=%lf %lf&quot;,
 			   &amp;gpsdata-&gt;fix.latitude, &amp;gpsdata-&gt;fix.longitude);
-		        gpsdata-&gt;valid |= LATLON_SET;
+		        gpsdata-&gt;set |= LATLON_SET;
 		    }
 		    break;
 		case 'Q':
@@ -252,7 +310,7 @@
 		        sscanf(sp, &quot;Q=%d %lf %lf %lf&quot;,
 			   &amp;gpsdata-&gt;satellites_used,
 			   &amp;gpsdata-&gt;pdop, &amp;gpsdata-&gt;hdop, &amp;gpsdata-&gt;vdop);
-		        gpsdata-&gt;valid |= HDOP_SET | VDOP_SET | PDOP_SET;
+		        gpsdata-&gt;set |= HDOP_SET | VDOP_SET | PDOP_SET;
 		    }
 		    break;
 		case 'S':
@@ -260,7 +318,7 @@
 		        gpsdata-&gt;status = -1;
 		    } else {
 		        gpsdata-&gt;status = atoi(sp+2);
-		        gpsdata-&gt;valid |= STATUS_SET;
+		        gpsdata-&gt;set |= STATUS_SET;
 		    }
 		    break;
 		case 'T':
@@ -268,7 +326,7 @@
 		        gpsdata-&gt;fix.track = TRACK_NOT_VALID;
 		    } else {
 		        sscanf(sp, &quot;T=%lf&quot;, &amp;gpsdata-&gt;fix.track);
-		        gpsdata-&gt;valid |= TRACK_SET;
+		        gpsdata-&gt;set |= TRACK_SET;
 		    }
 		    break;
 		case 'U':
@@ -276,7 +334,7 @@
 		        gpsdata-&gt;fix.climb = SPEED_NOT_VALID;
 		    } else {
 		        sscanf(sp, &quot;U=%lf&quot;, &amp;gpsdata-&gt;fix.climb);
-		        gpsdata-&gt;valid |= CLIMB_SET;
+		        gpsdata-&gt;set |= CLIMB_SET;
 		    }
 		    break;
 		case 'V':
@@ -284,7 +342,7 @@
 		        gpsdata-&gt;fix.speed = SPEED_NOT_VALID;
 		    } else {
 		        sscanf(sp, &quot;V=%lf&quot;, &amp;gpsdata-&gt;fix.speed);
-		        gpsdata-&gt;valid |= SPEED_SET;
+		        gpsdata-&gt;set |= SPEED_SET;
 		    }
 		    break;
 		case 'X':
@@ -292,7 +350,7 @@
 			gpsdata-&gt;online = -1;
 		    else {
 			sscanf(sp, &quot;X=%lf&quot;, &amp;gpsdata-&gt;online);
-			gpsdata-&gt;valid |= ONLINE_SET;
+			gpsdata-&gt;set |= ONLINE_SET;
 		    }
 		    break;
 		case 'Y':
@@ -310,7 +368,7 @@
 			strncpy(gpsdata-&gt;tag, tag, MAXTAGLEN);
 			if (timestamp[0] != '?') {
 			    gpsdata-&gt;sentence_time = atof(timestamp);
-			    gpsdata-&gt;valid |= TIME_SET;
+			    gpsdata-&gt;set |= TIME_SET;
 			}
 			for (j = 0; j &lt; gpsdata-&gt;satellites; j++) {
 			    PRN[j]=elevation[j]=azimuth[j]=ss[j]=used[j]=0;
@@ -340,7 +398,7 @@
 			memcpy(gpsdata-&gt;ss, ss, sizeof(ss));
 			memcpy(gpsdata-&gt;used, used, sizeof(used));
 		    }
-		    gpsdata-&gt;valid |= SATELLITE_SET;
+		    gpsdata-&gt;set |= SATELLITE_SET;
 		    break;
 		case 'Z':
 		    sscanf(sp, &quot;Z=%d&quot;, &amp;gpsdata-&gt;profiling);
@@ -379,12 +437,9 @@
 
     /* the daemon makes sure that every read is NUL-terminated */
     n = read(gpsdata-&gt;gps_fd, buf, sizeof(buf)-1);
-    if (n &lt; 0) {
-        /* error */
+    if (n &lt;= 0) {
+        /* error or nothiung read */
 	return -1;
-    } else if ( n == 0 ) {
-        /* nothing read */
-	return 0;
     }
     buf[n] = '\0';
 
@@ -416,17 +471,17 @@
     char *status_values[] = {&quot;NO_FIX&quot;, &quot;FIX&quot;, &quot;DGPS_FIX&quot;};
     char *mode_values[] = {&quot;&quot;, &quot;NO_FIX&quot;, &quot;MODE_2D&quot;, &quot;MODE_3D&quot;};
 
-    if (collect-&gt;valid &amp; ONLINE_SET)
+    if (collect-&gt;set &amp; ONLINE_SET)
 	printf(&quot;online: %lf\n&quot;, collect-&gt;online);
-    if (collect-&gt;valid &amp; LATLON_SET)
+    if (collect-&gt;set &amp; LATLON_SET)
 	printf(&quot;P: lat/lon: %lf %lf\n&quot;, collect-&gt;fix.latitude, collect-&gt;fix.longitude);
-    if (collect-&gt;valid &amp; ALTITUDE_SET)
+    if (collect-&gt;set &amp; ALTITUDE_SET)
 	printf(&quot;A: altitude: %lf  U: climb: %lf\n&quot;, 
 	       collect-&gt;fix.altitude, collect-&gt;fix.climb);
     if (collect-&gt;fix.track != TRACK_NOT_VALID)
 	printf(&quot;T: track: %lf  V: speed: %lf\n&quot;, 
 	       collect-&gt;fix.track, collect-&gt;fix.speed);
-    if (collect-&gt;valid &amp; STATUS_SET)
+    if (collect-&gt;set &amp; STATUS_SET)
 	printf(&quot;S: status: %d (%s)\n&quot;, 
 	       collect-&gt;status, status_values[collect-&gt;status]);
     if (collect-&gt;fix.mode &amp; MODE_SET)
@@ -437,7 +492,7 @@
 	   collect-&gt;satellites_used, 
 	   collect-&gt;pdop, collect-&gt;hdop, collect-&gt;vdop);
 
-    if (collect-&gt;valid &amp; SATELLITE_SET) {
+    if (collect-&gt;set &amp; SATELLITE_SET) {
 	int i;
 
 	printf(&quot;Y: satellites in view: %d\n&quot;, collect-&gt;satellites);
@@ -445,11 +500,11 @@
 	    printf(&quot;    %2.2d: %2.2d %3.3d %3.3d %c\n&quot;, collect-&gt;PRN[i], collect-&gt;elevation[i], collect-&gt;azimuth[i], collect-&gt;ss[i], collect-&gt;used[i]? 'Y' : 'N');
 	}
     }
-    if (collect-&gt;valid &amp; DEVICE_SET)
+    if (collect-&gt;set &amp; DEVICE_SET)
 	printf(&quot;Device is %s\n&quot;, collect-&gt;gps_device);
-    if (collect-&gt;valid &amp; DEVICEID_SET)
+    if (collect-&gt;set &amp; DEVICEID_SET)
 	printf(&quot;GPSD ID is %s\n&quot;, collect-&gt;gps_id);
-    if (collect-&gt;valid &amp; DEVICELIST_SET) {
+    if (collect-&gt;set &amp; DEVICELIST_SET) {
 	int i;
 	printf(&quot;%d devices:\n&quot;, collect-&gt;ndevices);
 	for (i = 0; i &lt; collect-&gt;ndevices; i++) {
@@ -492,7 +547,7 @@
 		    putchar('\n');
 		break;
 	    }
-	    collect-&gt;valid = 0;
+	    collect-&gt;set = 0;
 	    gps_query(collect, buf);
 	    data_dump(collect, time(NULL));
 	}
diff -r -u gpsd-2.21/libgpsd_core.c gpsd-2.22/libgpsd_core.c
--- gpsd-2.21/libgpsd_core.c	2005-04-11 17:56:22.000000000 -0400
+++ gpsd-2.22/libgpsd_core.c	2005-04-13 12:11:55.000000000 -0400
@@ -130,7 +130,7 @@
     session-&gt;gpsdata.sentence_length = session-&gt;outbuflen;
     session-&gt;gpsdata.d_recv_time = timestamp();
 
-    session-&gt;gpsdata.valid = ONLINE_SET | session-&gt;device_type-&gt;parse_packet(session);
+    session-&gt;gpsdata.set = ONLINE_SET | session-&gt;device_type-&gt;parse_packet(session);
 
     /* count all packets and good fixes */
     session-&gt;counter++;
@@ -152,23 +152,23 @@
      */
     session-&gt;gpsdata.fix.ept = 0.005;
 #ifdef BINARY_ENABLE
-    if (session-&gt;gpsdata.valid &amp; LATLON_SET) {
-	if (!(session-&gt;gpsdata.valid &amp; HERR_SET) 
-	    &amp;&amp; (session-&gt;gpsdata.valid &amp; HDOP_SET)) {
+    if (session-&gt;gpsdata.set &amp; LATLON_SET) {
+	if (!(session-&gt;gpsdata.set &amp; HERR_SET) 
+	    &amp;&amp; (session-&gt;gpsdata.set &amp; HDOP_SET)) {
 	    session-&gt;gpsdata.fix.eph = session-&gt;gpsdata.hdop*UERE(session);
-	    session-&gt;gpsdata.valid |= HERR_SET;
+	    session-&gt;gpsdata.set |= HERR_SET;
 	}
-	if (!(session-&gt;gpsdata.valid &amp; VERR_SET) 
-	    &amp;&amp; (session-&gt;gpsdata.valid &amp; VDOP_SET)) {
+	if (!(session-&gt;gpsdata.set &amp; VERR_SET) 
+	    &amp;&amp; (session-&gt;gpsdata.set &amp; VDOP_SET)) {
 	    session-&gt;gpsdata.fix.epv = session-&gt;gpsdata.vdop*UERE(session);
-	    session-&gt;gpsdata.valid |= VERR_SET;
+	    session-&gt;gpsdata.set |= VERR_SET;
 	}
-	if (!(session-&gt;gpsdata.valid &amp; PERR_SET) 
-	    &amp;&amp; (session-&gt;gpsdata.valid &amp; PDOP_SET)) {
+	if (!(session-&gt;gpsdata.set &amp; PERR_SET) 
+	    &amp;&amp; (session-&gt;gpsdata.set &amp; PDOP_SET)) {
 	    session-&gt;gpsdata.epe = session-&gt;gpsdata.pdop*UERE(session);
-	    session-&gt;gpsdata.valid |= PERR_SET;
+	    session-&gt;gpsdata.set |= PERR_SET;
 	}
-	if (!(session-&gt;gpsdata.valid &amp; SPEEDERR_SET) &amp;&amp; session-&gt;gpsdata.fix.time &gt; session-&gt;lastfix.time) {
+	if (!(session-&gt;gpsdata.set &amp; SPEEDERR_SET) &amp;&amp; session-&gt;gpsdata.fix.time &gt; session-&gt;lastfix.time) {
 	    session-&gt;gpsdata.fix.eps = 0.0;
 	    if (session-&gt;lastfix.mode &gt; MODE_NO_FIX 
 		&amp;&amp; session-&gt;gpsdata.fix.mode &gt; MODE_NO_FIX) {
@@ -176,10 +176,10 @@
 		double e = session-&gt;lastfix.eph + session-&gt;gpsdata.fix.eph;
 		session-&gt;gpsdata.fix.eps = e/t;
 		if (session-&gt;gpsdata.fix.eps)
-		    session-&gt;gpsdata.valid |= SPEEDERR_SET;
+		    session-&gt;gpsdata.set |= SPEEDERR_SET;
 	    }
 	}
-	if (!(session-&gt;gpsdata.valid &amp; CLIMBERR_SET) &amp;&amp; session-&gt;gpsdata.fix.time &gt; session-&gt;lastfix.time) {
+	if (!(session-&gt;gpsdata.set &amp; CLIMBERR_SET) &amp;&amp; session-&gt;gpsdata.fix.time &gt; session-&gt;lastfix.time) {
 	    session-&gt;gpsdata.fix.epc = 0.0;
 	    if (session-&gt;lastfix.mode &gt; MODE_3D 
 		&amp;&amp; session-&gt;gpsdata.fix.mode &gt; MODE_3D) {
@@ -188,7 +188,7 @@
 		/* if vertical uncertainties are zero this will be too */
 		session-&gt;gpsdata.fix.epc = e/t;
 		if (session-&gt;gpsdata.fix.epc)
-		    session-&gt;gpsdata.valid |= CLIMBERR_SET;
+		    session-&gt;gpsdata.set |= CLIMBERR_SET;
 	    }
 	}
 
@@ -214,7 +214,7 @@
 	    gpsd_report(2, &quot;=&gt; dgps %s&quot;, buf);
 	}
     }
-    return session-&gt;gpsdata.valid;
+    return session-&gt;gpsdata.set;
 }
 
 int gpsd_poll(struct gps_device_t *session)
diff -r -u gpsd-2.21/sirf.c gpsd-2.22/sirf.c
--- gpsd-2.21/sirf.c	2005-04-12 14:09:58.000000000 -0400
+++ gpsd-2.22/sirf.c	2005-04-21 12:31:26.000000000 -0400
@@ -19,7 +19,7 @@
  * to navigate in the absence of satellite information, and 
  * to improve fixes when you do have satellites.)&quot;
  *
- * Why we don't use packet 42 (Geodetic Navigation Information): 
+ * Why we only use packet 42 (Geodetic Navigation Information) conditionally: 
  *
  * Many versions of the SiRF protocol manual don't document 
  * this sentence at all.  Those that do may incorrectly
@@ -135,6 +135,16 @@
 {
     int	st, i, j, cn, navtype, mask;
     char buf2[MAX_PACKET_LENGTH*3] = &quot;&quot;;
+    double fv;
+    u_int8_t disablesubframe[] = {0xa0, 0xa2, 0x00, 0x19,
+				  0x80, 0x00, 0x00, 0x00,
+				  0x00, 0x00, 0x00, 0x00,
+				  0x00, 0x00, 0x00, 0x00,
+				  0x00, 0x00, 0x00, 0x00,
+				  0x00, 0x00, 0x00, 0x00,
+				  0x00, 0x00, 0x00, 0x0C,
+				  0x00,
+				  0x00, 0x00, 0xb0, 0xb3};
 
     buf2[0] = '\0';
     for (i = 0; i &lt; len; i++)
@@ -146,56 +156,56 @@
     {
     case 0x02:		/* Measure Navigation Data Out */
 	mask = 0;
-	/* position/velocity is bytes 1-18 */
-	ecef_to_wgs84fix(&amp;session-&gt;gpsdata.fix, 
-		    getl(1), getl(5), getl(9),
-		    getw(13)/8.0, getw(15)/8.0, getw(17)/8.0);
-	/* WGS 84 geodesy parameters */
-	/* fix status is byte 19 */
-	navtype = getb(19);
-	session-&gt;gpsdata.status = STATUS_NO_FIX;
-	session-&gt;gpsdata.fix.mode = MODE_NO_FIX;
-	if (navtype &amp; 0x80)
-	    session-&gt;gpsdata.status = STATUS_DGPS_FIX;
-	else if ((navtype &amp; 0x07) &gt; 0 &amp;&amp; (navtype &amp; 0x07) &lt; 7)
-	    session-&gt;gpsdata.status = STATUS_FIX;
-	if ((navtype &amp; 0x07) == 4 || (navtype &amp; 0x07) == 6)
-	    session-&gt;gpsdata.fix.mode = MODE_3D;
-	else if (session-&gt;gpsdata.status)
-	    session-&gt;gpsdata.fix.mode = MODE_2D;
-	if (session-&gt;gpsdata.fix.mode == MODE_3D)
-	    mask |= ALTITUDE_SET;
-	gpsd_report(4, &quot;MND 0x02: Navtype = 0x%0x, Status = %d, mode = %d\n&quot;, 
-		    navtype,session-&gt;gpsdata.status,session-&gt;gpsdata.fix.mode);
-	/* byte 20 is HDOP, see below */
-	/* byte 21 is &quot;mode 2&quot;, not clear how to interpret that */ 
-	session-&gt;gpsdata.fix.time = session-&gt;gpsdata.sentence_time
-	    = gpstime_to_unix(getw(22), getl(24)*1e-2, -session-&gt;context-&gt;leap_seconds);
+	if (!(session-&gt;driverstate &amp; (SIRF_GE_232 | UBLOX))) {
+	    /* position/velocity is bytes 1-18 */
+	    ecef_to_wgs84fix(&amp;session-&gt;gpsdata.fix, 
+			     getl(1), getl(5), getl(9),
+			     getw(13)/8.0, getw(15)/8.0, getw(17)/8.0);
+	    /* WGS 84 geodesy parameters */
+	    /* fix status is byte 19 */
+	    navtype = getb(19);
+	    session-&gt;gpsdata.status = STATUS_NO_FIX;
+	    session-&gt;gpsdata.fix.mode = MODE_NO_FIX;
+	    if (navtype &amp; 0x80)
+		session-&gt;gpsdata.status = STATUS_DGPS_FIX;
+	    else if ((navtype &amp; 0x07) &gt; 0 &amp;&amp; (navtype &amp; 0x07) &lt; 7)
+		session-&gt;gpsdata.status = STATUS_FIX;
+	    if ((navtype &amp; 0x07) == 4 || (navtype &amp; 0x07) == 6)
+		session-&gt;gpsdata.fix.mode = MODE_3D;
+	    else if (session-&gt;gpsdata.status)
+		session-&gt;gpsdata.fix.mode = MODE_2D;
+	    if (session-&gt;gpsdata.fix.mode == MODE_3D)
+		mask |= ALTITUDE_SET;
+	    gpsd_report(4, &quot;MND 0x02: Navtype = 0x%0x, Status = %d, mode = %d\n&quot;, 
+			navtype,session-&gt;gpsdata.status,session-&gt;gpsdata.fix.mode);
+	    /* byte 20 is HDOP, see below */
+	    /* byte 21 is &quot;mode 2&quot;, not clear how to interpret that */ 
+	    session-&gt;gpsdata.fix.time = session-&gt;gpsdata.sentence_time
+		= gpstime_to_unix(getw(22), getl(24)*1e-2, -session-&gt;context-&gt;leap_seconds);
 #ifdef NTPSHM_ENABLE
-	session-&gt;time_seen |= TIME_SEEN_GPS_2;
-	if (IS_HIGHEST_BIT(session-&gt;time_seen,TIME_SEEN_GPS_2))
-	    ntpshm_put(session, session-&gt;gpsdata.fix.time);
+	    session-&gt;time_seen |= TIME_SEEN_GPS_2;
+	    if (IS_HIGHEST_BIT(session-&gt;time_seen,TIME_SEEN_GPS_2))
+		ntpshm_put(session, session-&gt;gpsdata.fix.time);
 #endif /* NTPSHM_ENABLE */
 
-	gpsd_binary_fix_dump(session, buf2);
-	/* fix quality data */
-	session-&gt;gpsdata.hdop = getb(20)/5.0;
-	session-&gt;gpsdata.satellites_used = getb(28);
-	for (i = 0; i &lt; MAXCHANNELS; i++)
-	    session-&gt;gpsdata.used[i] = getb(29+i);
-	session-&gt;gpsdata.pdop = session-&gt;gpsdata.vdop = 0.0;
-	gpsd_binary_quality_dump(session, buf2 + strlen(buf2));
-	gpsd_report(3, &quot;&lt;= GPS: %s&quot;, buf2);
-	return mask | TIME_SET | LATLON_SET | TRACK_SET | SPEED_SET | STATUS_SET | MODE_SET | HDOP_SET;
+	    gpsd_binary_fix_dump(session, buf2);
+	    /* fix quality data */
+	    session-&gt;gpsdata.hdop = getb(20)/5.0;
+	    session-&gt;gpsdata.satellites_used = getb(28);
+#ifdef __UNUSED__
+	    if (session-&gt;gpsdata.satellites)
+		dop(session-&gt;gpsdata.satellites_used, &amp;session-&gt;gpsdata);
+#endif /* __UNUSED */
+	    for (i = 0; i &lt; MAXCHANNELS; i++)
+		session-&gt;gpsdata.used[i] = getb(29+i);
+	    session-&gt;gpsdata.pdop = session-&gt;gpsdata.vdop = 0.0;
+	    gpsd_binary_quality_dump(session, buf2 + strlen(buf2));
+	    gpsd_report(3, &quot;&lt;= GPS: %s&quot;, buf2);
+	    mask |= TIME_SET | LATLON_SET | TRACK_SET | SPEED_SET | STATUS_SET | MODE_SET | HDOP_SET;
+	}
+	return mask;
 
     case 0x04:		/* Measured tracker data out */
-	/*
-	 * The freaking brain-dead SiRF chip doesn't obey its own
-	 * rate-control command for 04, at least at firmware rev. 231, 
-	 * so we have to do our own rate-limiting here...
-	 */
-	if (session-&gt;counter % 5)
-	    break;
 	gpsd_zero_satellites(&amp;session-&gt;gpsdata);
 	for (i = st = 0; i &lt; MAXCHANNELS; i++) {
 	    int good, off = 8 + 15 * i;
@@ -230,22 +240,42 @@
 		st += 1;
 	}
 	session-&gt;gpsdata.satellites = st;
+	/*
+	 * The freaking brain-dead SiRF chip doesn't obey its own
+	 * rate-control command for 04, at least at firmware rev. 231, 
+	 * so we have to do our own rate-limiting here...
+	 */
+	if (session-&gt;counter % 5)
+	    break;
 	gpsd_binary_satellite_dump(session, buf2);
 	gpsd_report(4, &quot;MTD 0x04: %d satellites\n&quot;, st);
 	gpsd_report(3, &quot;&lt;= GPS: %s&quot;, buf2);
 	return TIME_SET | SATELLITE_SET;
 
     case 0x06:		/* Software Version String */
-	gpsd_report(4,&quot;FV  0x06: Firmware version: %s\n&quot;,session-&gt;outbuffer+5);
+	gpsd_report(4, &quot;FV  0x06: Firmware version: %s\n&quot;, 
+		    session-&gt;outbuffer+5);
+	fv = atof(session-&gt;outbuffer+5);
+	if (fv &lt; 231) {
+	    session-&gt;driverstate |= SIRF_LT_231;
+	    sirfbin_mode(session, 0);
+	} else if (fv &lt; 232) 
+	    session-&gt;driverstate |= SIRF_EQ_231;
+	else {
+	    session-&gt;driverstate |= SIRF_GE_232;
+	    session-&gt;context-&gt;valid |= LEAP_SECOND_VALID;
+	}
 	if (strstr(session-&gt;outbuffer+5, &quot;ES&quot;))
 	    gpsd_report(4, &quot;Firmware has XTrac capability\n&quot;);
 	gpsd_report(4, &quot;Driver state flags are: %0x\n&quot;, session-&gt;driverstate);
 	return 0;
 
     case 0x08:
-#ifdef SUBFRAME
 	/*
-	 * Heavy black mgic begins here!
+	 * Heavy black magic begins here!
+	 *
+	 * A description of how to decode these bits is at
+	 * &lt;<A HREF="http://home-2.worldonline.nl/~samsvl/nav2eu.htm">http://home-2.worldonline.nl/~samsvl/nav2eu.htm</A>&gt;
 	 *
 	 * We're after subframe 4 page 18 word 9, the leap year correction.
 	 *
@@ -259,7 +289,7 @@
 	 * changes 1 second every few years. Maybe.&quot;
 	 */
         {
-	    unsigned int i, pageid, subframe, words[10];
+	    unsigned int i, pageid, subframe, leap, words[10];
 	    unsigned int svid = getb(1);
 	    unsigned int chan = getb(2);
 	    words[0] = getl(3);
@@ -306,33 +336,54 @@
 		break;
 	    /*
 	     * Pages 66-76a,80 of ICD-GPS-200 are the subframe structures.
+	     * Subframe 4 page 18 is on page 74.
 	     * See page 105 for the mapping between magic SVIDs and pages.
 	     */
 	    pageid = (words[2] &amp; 0x3F0000) &gt;&gt; 16;
 	    gpsd_report(5, &quot;Subframe 4 SVID is %d\n&quot;, pageid);
 	    if (pageid == 56) {	/* magic SVID for page 18 */
-		u_int8_t disablesubframe[] = {0xa0, 0xa2, 0x00, 0x19,
-					      0x80, 0x00, 0x00, 0x00,
-					      0x00, 0x00, 0x00, 0x00,
-					      0x00, 0x00, 0x00, 0x00,
-					      0x00, 0x00, 0x00, 0x00,
-					      0x00, 0x00, 0x00, 0x00,
-					      0x00, 0x00, 0x00, 0x0C,
-					      0x00,
-					      0x00, 0x00, 0xb0, 0xb3};
 		/* once we've filtered, we can ignore the TEL and HOW words */
 		gpsd_report(5, &quot;50B: CH=%d, SV=%d SF=%d %06x %06x %06x %06x %06x %06x %06x %06x\n&quot;, 
 			    chan, svid, subframe,
 				words[2], words[3], words[4], words[5], 
 				words[6], words[7], words[8], words[9]);
-		session-&gt;context-&gt;leap_seconds = (words[9] &amp; 0xff0000) &gt;&gt; 16;
+		leap = (words[8] &amp; 0xff0000) &gt;&gt; 16;
+		/*
+		 * There appears to be some bizarre bug that randomly causes
+		 * this field to come out two's-complemented.  Work around
+		 * this.  At the current expected rate of issuing leap-seconds
+		 * this kluge won't bite until about 2070, by which time SiRF
+		 * had better have fixed their damn firmware...
+		 *
+		 * Carl: ...I am unsure, and suggest you
+		 * experiment.  The D30 bit is in bit 30 of the 32-bit
+		 * word (next to MSB), and should signal an inverted
+		 * value when it is one coming over the air.  But if
+		 * the bit is set and the word decodes right without
+		 * inversion, then we properly caught it.  Cases where
+		 * you see subframe 6 rather than 1 means we should
+		 * have done the inversion but we did not.  Some other
+		 * things you can watch for: in any subframe, the
+		 * second word (HOW word) should have last 2 parity
+		 * bits 00 -- there are bits within the rest of the
+		 * word that are set as required to ensure that.  The
+		 * same goes for word 10.  That means that both words
+		 * 1 and 3 (the words that immediately follow words 10
+		 * and 2, respectively) should always be uninverted.
+		 * In these cases, the D29 and D30 from the previous
+		 * words, found in the two MSBs of the word, should
+		 * show 00 -- if they don't then you may find an
+		 * unintended inversion due to noise on the data link.
+		 */
+		if (leap &gt; 128)
+		    leap ^= 0xff;
+		gpsd_report(2, &quot;leap-seconds is %d\n&quot;, leap);
+		session-&gt;context-&gt;leap_seconds = leap;
 		session-&gt;context-&gt;valid = LEAP_SECOND_VALID;
-		gpsd_report(2, &quot;Leap-seconds is %d\n&quot;, session-&gt;context-&gt;leap_seconds);
 		gpsd_report(4, &quot;Disabling subframe transmission...\n&quot;);
 		sirf_write(session-&gt;gpsdata.gps_fd, disablesubframe);
 	    }
 	}
-#endif /* SUBFRAME */
 	break;
     case 0x09:		/* CPU Throughput */
 	gpsd_report(4, 
@@ -377,7 +428,81 @@
 	return 0;
 
     case 0x29:		/* Geodetic Navigation Information */
-	return 0;
+	mask = 0;
+	if (session-&gt;driverstate &amp; SIRF_GE_232) {
+	    /*
+	     * Many versions of the SiRF protocol manual don't document 
+	     * this sentence at all.  Those that do may incorrectly
+	     * describe UTC Day, Hour, and Minute as 2-byte quantities,
+	     * not 1-byte. Chris Kuethe, our SiRF expert, tells us:
+	     *
+	     * &quot;The Geodetic Navigation packet (0x29) was not fully
+	     * implemented in firmware prior to version 2.3.2. So for
+	     * anyone running 231.000.000 or earlier (including ES,
+	     * SiRFDRive, XTrac trains) you won't get UTC time. I don't
+	     * know what's broken in firmwares before 2.3.1...&quot;
+	     *
+	     * To work around the incomplete implementation of this
+	     * packet in 231, we assume that only the altitude field
+	     * from this packet is valid.
+	     */
+	    navtype = getw(3);
+	    session-&gt;gpsdata.status = STATUS_NO_FIX;
+	    session-&gt;gpsdata.fix.mode = MODE_NO_FIX;
+	    if (navtype &amp; 0x80)
+		session-&gt;gpsdata.status = STATUS_DGPS_FIX;
+	    else if ((navtype &amp; 0x07) &gt; 0 &amp;&amp; (navtype &amp; 0x07) &lt; 7)
+		session-&gt;gpsdata.status = STATUS_FIX;
+	    session-&gt;gpsdata.fix.mode = MODE_NO_FIX;
+	    if ((navtype &amp; 0x07) == 4 || (navtype &amp; 0x07) == 6)
+		session-&gt;gpsdata.fix.mode = MODE_3D;
+	    else if (session-&gt;gpsdata.status)
+		session-&gt;gpsdata.fix.mode = MODE_2D;
+	    gpsd_report(4, &quot;GNI 0x29: Navtype = 0x%0x, Status = %d, mode = %d\n&quot;, 
+			navtype, session-&gt;gpsdata.status, session-&gt;gpsdata.fix.mode);
+	    /*
+	     * UTC is left all zeros in 231 and older firmware versions, 
+	     * and misdocumented in the Protocol Reference (version 1.4).
+	     *            Documented:        Real:
+	     * UTC year       2               2
+	     * UTC month      1               1
+	     * UTC day        2               1
+	     * UTC hour       2               1
+	     * UTC minute     2               1
+	     * UTC second     2               2
+	     *                11              8
+	     */
+	    session-&gt;gpsdata.nmea_date.tm_year = getw(11);
+	    session-&gt;gpsdata.nmea_date.tm_mon = getb(13)-1;
+	    session-&gt;gpsdata.nmea_date.tm_mday = getb(14);
+	    session-&gt;gpsdata.nmea_date.tm_hour = getb(15);
+	    session-&gt;gpsdata.nmea_date.tm_min = getb(16);
+	    session-&gt;gpsdata.nmea_date.tm_sec = 0;
+	    session-&gt;gpsdata.subseconds = getw(17)*1e-3;
+	    session-&gt;gpsdata.fix.time = session-&gt;gpsdata.sentence_time
+		= mktime(&amp;session-&gt;gpsdata.nmea_date)+session-&gt;gpsdata.subseconds;
+	    gpsd_report(5, &quot;MID 41 UTC: %lf\n&quot;, session-&gt;gpsdata.fix.time);
+	    /* skip 4 bytes of satellite map */
+	    session-&gt;gpsdata.fix.latitude = getl(23)*1e-7;
+	    session-&gt;gpsdata.fix.longitude = getl(27)*1e-7;
+	    /* skip 4 bytes of altitude from ellipsoid */
+	    mask = TIME_SET | LATLON_SET | STATUS_SET | MODE_SET;
+	    session-&gt;gpsdata.fix.altitude = getl(31)*1e-2;
+	    /* skip 1 byte of map datum */
+	    session-&gt;gpsdata.fix.speed = getw(36)*1e-2;
+	    session-&gt;gpsdata.fix.track = getw(38)*1e-2;
+	    /* skip 2 bytes of magnetic variation */
+	    session-&gt;gpsdata.fix.climb = getw(42)*1e-2;
+	    /* HDOP should be available at byte 89, but in 231 it's zero. */
+	    gpsd_binary_fix_dump(session, buf2);
+	    gpsd_report(3, &quot;&lt;= GPS: %s&quot;, buf2);
+	    mask |= SPEED_SET | TRACK_SET | CLIMB_SET; 
+	    session-&gt;gpsdata.sentence_length = 91;
+	    strcpy(session-&gt;gpsdata.tag, &quot;GND&quot;);
+	    gpsd_report(4, &quot;Disabling subframe transmission...\n&quot;);
+	    sirf_write(session-&gt;gpsdata.gps_fd, disablesubframe);
+	}
+	return mask;
 
     case 0x32:		/* SBAS corrections */
 	return 0;
@@ -430,6 +555,9 @@
 	session-&gt;gpsdata.hdop = getb(36) / 5.0;
 	session-&gt;gpsdata.vdop = getb(37) / 5.0;
 	/* session-&gt;gpsdata.tdop = getb(38) / 5.0; */
+	session-&gt;driverstate |= UBLOX;
+	//gpsd_report(4, &quot;Disabling subframe transmission...\n&quot;);
+	//sirf_write(session-&gt;gpsdata.gps_fd, disablesubframe);
 	return mask;
 
     case 0xff:		/* Debug messages */
@@ -491,7 +619,19 @@
 	u_int8_t versionprobe[] = {0xa0, 0xa2, 0x00, 0x02,
 				 0x84, 0x00,
 				 0x00, 0x00, 0xb0, 0xb3};
-#ifdef SUBFRAME
+	u_int8_t modecontrol[] = {0xa0, 0xa2, 0x00, 0x0e,
+				  0x88, 
+				  0x00, 0x00,	/* pad bytes */
+				  0x00,		/* degraded mode off */
+				  0x00, 0x00,	/* pad bytes */
+				  0x00, 0x00,	/* altitude */
+				  0x00,		/* altitude hold auto */
+				  0x00,		/* use last computed alt */
+				  0x00,		/* reserved */
+				  0x00,		/* disable degraded mode */
+				  0x00,		/* disable dead reckoning */
+				  0x01,		/* enable track smoothing */
+				 0x00, 0x00, 0xb0, 0xb3};
 	u_int8_t enablesubframe[] = {0xa0, 0xa2, 0x00, 0x19,
 				 0x80, 0x00, 0x00, 0x00,
 				 0x00, 0x00, 0x00, 0x00,
@@ -501,19 +641,18 @@
 				 0x00, 0x00, 0x00, 0x0C,
 				 0x10,
 				 0x00, 0x00, 0xb0, 0xb3};
-#endif /* SUBFRAME */
 	gpsd_report(4, &quot;Setting DGPS control to use SBAS...\n&quot;);
 	sirf_write(session-&gt;gpsdata.gps_fd, dgpscontrol);
 	gpsd_report(4, &quot;Setting SBAS to auto/integrity mode...\n&quot;);
 	sirf_write(session-&gt;gpsdata.gps_fd, sbasparams);
 	gpsd_report(4, &quot;Probing for firmware version...\n&quot;);
 	sirf_write(session-&gt;gpsdata.gps_fd, versionprobe);
-#ifdef SUBFRAME
+	gpsd_report(4, &quot;setting mode...\n&quot;);
+	sirf_write(session-&gt;gpsdata.gps_fd, modecontrol);
 	if (!(session-&gt;context-&gt;valid &amp; LEAP_SECOND_VALID)) {
 	    gpsd_report(4, &quot;Enabling subframe transmission...\n&quot;);
 	    sirf_write(session-&gt;gpsdata.gps_fd, enablesubframe);
 	}
-#endif /* SUBFRAME */
     }
 }
 
diff -r -u gpsd-2.21/sirfmon.c gpsd-2.22/sirfmon.c
--- gpsd-2.21/sirfmon.c	2005-04-12 17:34:37.000000000 -0400
+++ gpsd-2.22/sirfmon.c	2005-04-20 18:30:17.000000000 -0400
@@ -536,6 +536,21 @@
 		sendpkt(buf,2);
 		break;
 
+	    case 'd':		/* MID 4 rate change -- not documented */
+		v = atoi(line+1);
+		if (v &gt; 30)
+		    break;
+		putb(0,0xa6);
+		putb(1,0);
+		putb(2, 4);	/* satellite picture */
+		putb(3, v);
+		putb(4, 0);
+		putb(5, 0);
+		putb(6, 0);
+		putb(7, 0);
+		sendpkt(buf,8);
+		break;
+
 	    case 'n':				/* switch to NMEA */
 		putb(0,0x81);			/* id */
 		putb(1,0x02);			/* mode */
diff -r -u gpsd-2.21/xgps.c gpsd-2.22/xgps.c
--- gpsd-2.21/xgps.c	2005-04-12 16:01:15.000000000 -0400
+++ gpsd-2.22/xgps.c	2005-04-22 08:04:32.000000000 -0400
@@ -229,7 +229,10 @@
 static void handle_input(XtPointer client_data UNUSED, int *source UNUSED,
 			 XtInputId *id UNUSED)
 {
-    gps_poll(gpsdata);
+    if (gps_poll(gpsdata) &lt; 0) {
+	fprintf(stderr, &quot;Read error on server socket.&quot;);
+	exit(1);
+    }
 }
 
 static void update_panel(struct gps_data_t *gpsdata, char *message)
-- 
		&lt;a href=&quot;<A HREF="http://www.catb.org/~esr/">http://www.catb.org/~esr/</A>&quot;&gt;Eric S. Raymond&lt;/a&gt;

A true libertarian supports free enterprise, opposes big business;
supports local self-government, opposes the nation-state; supports the
National Rifle Association, opposes the Pentagon.	-- Edward Abbey

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001712.html">[Gpsd-dev] Announcing release 2.24 of gpsd
</A></li>
	<LI>Next message: <A HREF="001723.html">[Gpsd-dev] link to the ebuild on the website
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1715">[ date ]</a>
              <a href="thread.html#1715">[ thread ]</a>
              <a href="subject.html#1715">[ subject ]</a>
              <a href="author.html#1715">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/gpsd-dev">More information about the Gpsd-dev
mailing list</a><br>
</body></html>
